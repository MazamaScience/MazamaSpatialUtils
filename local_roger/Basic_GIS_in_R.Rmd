---
title: "Basic GIS Operations in R"
author: "Roger Andre, Mazama Science"
date: "March 9, 2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic GIS in Rs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Objective

The goal of this document is to show how basic spatial operations common to Geographic Information Systems (GIS) can be done in R using S4 objects and the _sp_ and _raster_ packages.  I have chosen to focus on vector data, specifically point and polygon sets, as those are the ones most commonly encountered when using the MazamaSpatialUtils.

## Creating Spatial Polygon Data Frames

An easy way to create a rectangular Spatial Polygon Data Frame is to use the Bounding Box, or extent, of another spatial feature to define the geometry of the feature you want to create.  A separate data frame with feature attributes can then be attached to this geometry 
to form a SpatialPolygonsDataFrame.

```{r polygon_a_creation, message=FALSE}
library(raster)

# polygon A
poly_a <- as(raster::extent(2.0, 11.0, 9.0, 15.0), "SpatialPolygons")
df_a <- data.frame(name="A", id=1, county=1, type="tract", zone=1)

spdf_a <- SpatialPolygonsDataFrame(poly_a,df_a)
```

```{r polygon_bcde_creation, include=FALSE, message=FALSE}
# polygon B
poly_b <- as(raster::extent(11.0, 20.0, 9.0, 15.0), "SpatialPolygons")
df_b <- data.frame(name="B", id=2, county=1, type="tract", zone=1)
spdf_b <- SpatialPolygonsDataFrame(poly_b,df_b)

# polygon C
poly_c <- as(raster::extent(11.0, 20.0, 2.0, 9.0), "SpatialPolygons")
df_c <- data.frame(name="C", id=3, county=1, type="tract", zone=2)
spdf_c <- SpatialPolygonsDataFrame(poly_c,df_c)

# polygon D
poly_d <- as(raster::extent(2.0, 11.0, 2.0, 9.0), "SpatialPolygons")
df_d <- data.frame(name="D", id=4, county=1, type="tract", zone=2)
spdf_d <- SpatialPolygonsDataFrame(poly_d,df_d)

# polygon E
poly_e <- as(raster::extent(8.0, 25.0, 6.0, 25.0), "SpatialPolygons")
df_e <- data.frame(name="E", id=1, county=2, type="forest")
spdf_e <- SpatialPolygonsDataFrame(poly_e,df_e)
```

If multiple features are present, it's possible to bind them all into a single 
multiploygon feature.  Here 4 separate polygons; _"spdf_a", "spdf_b", "spdf_c"_ and 
_"spdf_d"_ are combined into a single new feature named _"spdf_abcd"_.

```{r polygon_merging}
# Define a coordinate reference system to use on all features
grs80 <- CRS("+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs +towgs84=0,0,0 +units=m")

# "Bind" Polys A,B,C & D into one multipolygon SPDF
spdf_abcd <- raster::bind(spdf_a, spdf_b, spdf_c, spdf_d, keepnames=TRUE)
proj4string(spdf_abcd) <- grs80

summary(spdf_abcd)
```

Note that a CRS has been assigned to the new feature.  This is needed in order to 
do spatial comparisons bewteen this feature and others later on.

## Creating Spatial Points Data Frames

There are multiple ways in which points can be converted into Spatial Point Data Frames.  
They share the same basic idea though - take a regular data frame which contains X and Y values that define point coordinates and then convert it into a `SpatialPointsDataFrame` function.  Two ways are shown below.  In both cases, a data frame is used to define the point locations and attributes of the data. 

```{r point_dataframe}
# Create a data frame with coordinates and some data, temperature readings, perhaps...
temp_df <- read.table(header = TRUE, text="
id  x  y  temp
 1  5  21 50
 2  18 20 49.5
 3  9  13 52
 4  17 13 51
 5  7  12  53
 6  23 12 50
 7  12 11 52
 8  6  7  57
 9  10 7  57
 10 15 7  55
 11 16 3  54
 12 22 3  54")

```
#### Method 1
```{r point_creation_1}
# Extract the x and y coordinates as a separate vector
xy <- temp_df[c("x", "y")]

# Convert the point df into a SpatialPointsDataFrame
temp_spdf <- SpatialPointsDataFrame(coords = xy, 
                                    data = temp_df,
                                    proj4string = grs80)

summary(temp_spdf)
```

#### Method 2
```{r point_creation_2}
# Use the coordinates() function to define the coordinate fields
coordinates(temp_df) <- ~x+y
proj4string(temp_df) <- grs80

summary(temp_df)
```

Method 2 converts the data frame in place and in doing so, the columns with the coordinate values are moved out of the `@data` slot.  This can be advantageous if you don't need the coordinates for anything more than to define the point geometry.

## Basic Plotting

Now that we have some features created, what do they look like?  The basic `plot()` function works extremely well with S4 Spatial objects.  One thing to keep in mind, though, is that the first feature plotted defines the plot extents.  One way to take advantage of this is to create a "map area" feature which can be used to both center subsequent plots and also to define a neatline for the map.

```{r basic_plot, fig.width=7, fig.height=7, fig.align='center'}
# bbox (just needed to be able to plot 2 objects that don't share the same bbox)
bbox <- as(raster::extent(0, 27.0, 0, 27.0), "SpatialPolygons")

# Invisible bbox to set the plot extent
plot(bbox, col = "transparent", border = "transparent")

# Plot polygon features
plot(spdf_e, col = "lightgreen", add = TRUE)
plot(spdf_abcd, col = "pink", add = TRUE)

# Plot the points and label them
plot(temp_spdf, add = TRUE, col = "black", pch = 16)
# Label the points
text(temp_spdf, labels = temp_spdf$id, pos = 3)

# Overplot the bbox as a neatline
plot(bbox, add = TRUE)
```

## Basic Spatial Analysis Operations

Generally speaking, there are 5 operations commonly performed while doing spatial analysis.
(Taken from [5 common ArcToolbox Tools](https://www.lib.umd.edu/binaries/content/assets/public/gov-info-gis/research-and-instruction/spatial-analysis-workbook.pdf) section of online paper by Univ. or Maryland.)

1. Buffer
2. Intersect
3. Clip
4. Dissolve
5. Spatial Join

The _raster_ package provides the functionality to do all of these operations.

## Buffer

The `buffer()` function uses the units of the map projection as the units by which to 
buffer objects.  Often a buffer is used to define a zone around a specific point.  Here, we will create a 250,000 meter buffer around Point 2.

```
# Subset a single point out of set
point_2 <- subset(temp_spdf, id == 2)

# Buffer around the point
buffer_zone <- buffer(point_2, width=250000)

# plot the point
plot(point_2, add = TRUE, col = "black", pch = 16)
text(point_2, labels = point_2$id, pos = 3)

# plot the buffer
plot(buffer_zone, add = TRUE)
```

```{r buffer_points, fig.width=7, fig.height=7, fig.align='center', message=FALSE, echo=FALSE}

# Invisible bbox to set the plot extent
plot(bbox, col = "transparent", border = "transparent")

# Plot polygon features
plot(spdf_e, col = "lightgreen", add = TRUE)
plot(spdf_abcd, col = "pink", add = TRUE)

# Subset a single point out of set
point_2 <- subset(temp_spdf, id == 2)

# Buffer around the point
buffer_zone <- buffer(point_2, width=250000)

# plot the point
plot(point_2, add = TRUE, col = "black", pch = 16)
text(point_2, labels = point_2$id, pos = 3)

# plot the buffer
plot(buffer_zone, add = TRUE)
plot(bbox, add=TRUE)
```

## Intersection

One problem, or perhaps "side-effect" of creating buffers is that the resulting feature will lack any sort of attribute information.  This can be rectified by using the _intersection()_ function.

```{r}
summary(buffer_zone)

point_2_zone <- raster::intersect(point_2, buffer_zone)
summary(point_2_zone)
```

